package edu.neumont.csc252;

public class AVLTree<T extends Comparable<T>> {

	private AVLNode<T> root;
	
	public AVLTree(){
		
	}
	
	public boolean insert(AVLNode<T> node){
		
		return insertNode(root, node);
	}
	
	private boolean insertNode(AVLNode<T> root, AVLNode<T> node){
		if(root.compareTo(node) == 0){
			return false;
		}
		
		if (root.getLeft() == null && root.getRight() == null){
			if (root.compareTo(node) < 0){
				root.setLeft(node);
			}else if (root.compareTo(node) > 0){
				root.setRight(node);
			}
			return true;
		}
		
		return false;
	}
	
	public boolean delete(AVLNode<T> node){
		
		return false;
	}
	
	public boolean search(AVLNode<T> node){
		
		return searchTree(root, node) != null;
	}
	
	private AVLNode<T> searchTree(AVLNode<T> root, AVLNode<T> node){
		
		if (root.compareTo(node) == 0){
			return root;
		}
		else if (root.getLeft() == null && root.getRight() == null){
			return null;
		}
		
		if (root.compareTo(node) < 0){
			return searchTree(root.getLeft(), node);
		}
		else if (root.compareTo(node) > 0){
			return searchTree(root.getRight(), node);
		}
		
		return null;
	}
	
	public boolean getSmallest(){
		
		return getSmallestValue(root) != null;
	}
	
	private T getSmallestValue(AVLNode<T> root){
		
		if (root.getLeft() == null && root.getRight() == null){
			return root.getValue();
		}
		
		return getSmallestValue(root.getLeft());
	}
}
