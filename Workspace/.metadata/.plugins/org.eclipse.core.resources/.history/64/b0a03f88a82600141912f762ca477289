package edu.neumont.csc252;

import java.util.Arrays;
import java.util.Iterator;

public class Heap<T extends Comparable<T>> {

	private T[] heap;
	private int index = 1;

	@SuppressWarnings("unchecked")
	public Heap(){
		heap = (T[]) new Comparable[8];
	}

	@SuppressWarnings("unchecked")
	public Heap(int initialSize){
		heap = (T[]) new Comparable[initialSize];
	}

	public Iterator<T> getIterator(){
		return new MyIterator();
	}

	public boolean insert(T t){

		for (T t1 : heap){
			if(t1 != null){
				if (t1.compareTo(t) == 0){
					return false;
				}
			}
		}

		heap[index] = t;

		if (index > heap.length){
			heap = Arrays.copyOf(heap, heap.length * 2);
		}

		if (index > 1){
			insertHelper(index);
		}

		index++; 

		return true;
	}

	private void insertHelper(int index){

		if (index < 2){
			return;
		}

		if (heap[index].compareTo(heap[index/2]) > 0){
			T temp = heap[index];
			heap[index] = heap[index/2];
			heap[index/2] = temp;
			insertHelper(index/2);
		}

	}

	public T getSmallest(){

		return heap[getSmallestIndex(1)];
	}

	private int getSmallestIndex(int index) {

		if (heap[index * 2] != null && heap[index * 2 + 1] != null){
			if (heap[index * 2].compareTo(heap[index * 2 + 1]) > 0){
				return getSmallestIndex(index * 2 + 1);
			}
			else{
				return getSmallestIndex(index * 2);
			}
		}
		else if (heap[index * 2] == null){
			return index;
		}
		else if (heap[index * 2 + 1] == null){
			return index * 2;
		}
		
		if (index * 2 > heap.length){
			if (heap[index] != null && heap[index + 1] != null){
				if (heap[index].compareTo(heap[index + 1]) > 0){
					return index + 1;
				}
				else{
					return index;
				}

			}
			else if(heap[index] == null){
				return index / 2;
			}
			else if (heap[index + 1] == null){

				return index;
			}
		}
		
		return -1;
	}

	public T removeSmallest(){
		
		int i = getSmallestIndex(1);
		T temp = heap[i];
		heap[i] = null;
		
		while (i < heap.length - 1){
			heap[i] = heap[i++];
			heap[i] = null;
		}
		
		return temp;
	}

	class MyIterator implements Iterator<T>{

		int i = 1;
		@Override
		public boolean hasNext() {
			return heap[i] != null;
		}

		@Override
		public T next() {
			return heap[i++];
		}

		@Override
		public void remove() {
			// TODO Auto-generated method stub

		}

	}


}
